#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""This module provides the SimCLR v2 class.

https://paperswithcode.com/method/simclrv2

Author: Andres J. Sanchez-Fernandez
Email: sfandres@unex.es
Date: 2023-03-28
"""


import torch.nn as nn
import torchvision.models.resnet as resnet


class SimCLR(nn.Module):
    def __init__(
            self,
            backbone: str = 'resnet18',
            weights = None,
            feature_dim: int = 128
    ):
        """
        Constructor of the class.

        Args:
            backbone (str): chosen backbone model.
            weights (): pretrained weights or None.
            feature_dim (int): feature (space) dimension.
        """

        # Call the nn.Module superclass constructor.
        super(SimCLR, self).__init__()

        # Choose the backbone architecture based on the argument provided.
        if backbone == 'resnet18':
            self.backbone = resnet.resnet18(weights=weights)
            num_ftrs = self.backbone.fc.in_features
        elif backbone == 'resnet50':
            self.backbone = resnet.resnet50(weights=weights)
            num_ftrs = self.backbone.fc.in_features
        else:
            raise ValueError("Invalid backbone architecture")

        # Replace the last fully connected layer with an identity function.
        self.backbone.fc = nn.Identity()

        # Projector network to generate feature embeddings.
        hidden_dim = num_ftrs
        self.projection_head = nn.Sequential(
            nn.Linear(num_ftrs, hidden_dim),
            nn.ReLU(inplace=True),
            nn.Linear(hidden_dim, feature_dim)
        )

    def forward(self, x):
        """
        How your model runs from input to output.

        Args:
            x (tensor): batch of input images.

        Returns:
            h (tensor): feature embeddings generated by the projector network.
            g (tensor): predictions generated by the predictor network.
        """

        # Feature extraction using the ResNet backbone.
        z = self.backbone(x)

        # Feature embeddings.
        h = self.projection_head(z)

        return h
